<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dispatching custom events</title>
</head>
<body>
    <div id="div"></div>
    <script>
        // we can create custom events using Event class
        // it takes two arguments i.e. event name and options
        // options have following properties: bubbles (if true than the event bubbles), cancellable (if true than preventDefault() can be called)
        // both properties are false by default
        // Example
        let event = new Event('something', {
            bubbles: true
        });

        // it can be handled by an handler added by addEventListener()
        // NOTE that on<event> property can only add handler for real user events NOT the script generated events
        document.addEventListener('something', function (event){
            console.log('something event is handled');
        });

        // we can use elem.dispatchEvent(event) to trigger the event
        div.dispatchEvent(event);

        // event.isTrusted is true if the event is real user generated event and false if the event is script generated
        document.addEventListener('something', function (event){
            console.log(event.isTrusted);  // false
        });

        div.dispatchEvent(event);

        // we can also create event that can generated by user actions like click, mouseover and etc and dispatch them to simulate that event
        // Example
        div.addEventListener('click', function (event){
            console.log('div was clicked');
        });

        div.dispatchEvent(new Event('click'));

        // there are many classes that inherit Event class like MouseEvent, KeyboardEvent, CustomEvent and etc.
        // if we want to simulate a mouse event than we should use MouseEvent because in its OPTIONS arguments we can add value of its standard properties like clientX and clientY
        div.addEventListener('click', (event) => {
            console.log(event.clientX, event.clientY);
        });

        div.dispatchEvent(new Event('click'));  // clientX and clientY will be undefined

        div.dispatchEvent(new MouseEvent('click', {
            clientX: 100,
            clientY: 100
        }))  // now the clientX and clientY will be 100

        // when creating a custom event we should use CustomEvent because it provides an additional property in OPTIONS argument
        // that property is detail. we can add any event related information in it
        document.addEventListener('customevent', (event) => {
            console.log(event.detail);
        });

        div.dispatchEvent(new CustomEvent('customevent', {
            detail: {name: 'divyanshu', age: 21},
            bubbles: true
        }));

        // elem.dispatchEvent(event) returns false if event.preventDefault() is called by any handler
        // Example
        div.addEventListener('demoevent', (event) => {
            if (confirm('call event.defaultPrevent()?')){
                event.preventDefault();
            }
        });

        if (!div.dispatchEvent(new CustomEvent('demoevent', {
            cancelable: true  // without this the event.preventDefault() wont work
        }))){
            console.log('preventDefault was called');
        } else {
            console.log('some custom default behavior can be done');
        }

        // if an event occured while other event was handling than that is added to the queue and it will be handles after that event
        // but in case of nested events, it is handled synchrounously
        // Example
        document.addEventListener('dblclick', (event) => {
            console.log('before');

            document.dispatchEvent(new CustomEvent('demoevent2'));

            console.log('after');
        });

        document.addEventListener('demoevent2', (event) => {
            console.log('demo event is handled');  // the order will be before -> dome event -> after
        })
    </script>
</body>
</html>